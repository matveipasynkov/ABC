# Домашнее задание - 1 (Пасынков Матвей Евгеньевич, БПИ237)

# Отчёт о работе эмулятора

## Программа add-int01.s


 ![](/images/1.png "aspect=1")


Для начала скомпилируем наш файл с помощью кнопки Assemble и получим следующие результаты во вкладке Execute:


 ![](/images/2.png "aspect=1")


Далее запустим нашу программу и в Run I/O введём два числа 3 и 7. Программа выведет 10, то есть сумму данных чисел.


 ![Программа приняла 3 и 7, вывела 10 и успешно завершилась.](/images/3.png "aspect=1")

### Системные вызовы в add-int01.s

| № вызова | Значение |
|----|----|
| 5 | Считать целое число с консоли и сохранить результат в a0 |
| 1 | Вывести целое число, хранящееся в a0 |
| 10 | Завершить программу с кодом 0 |

## Программа hello01.s


 ![](/images/4.png "aspect=1")


Снова скомпилируем и получим следующие Text Segment и Data Segment:


 ![](/images/5.png "aspect=1")


Теперь запустим. Наша программа выведет "Hello! It works!!!" и успешно завершится:


 ![Программа вывела: "Hello! It works!!!" и успешно завершилась.](/images/6.png "aspect=1")

## Псевдокоды в программе hello01.s

Для того чтобы определить, где псевдокоды, а где нет, мы обратимся к результатам компиляции, которые хранятся во вкладке Execute, а точнее к Text Segment.


 ![](/images/7.png "aspect=1")


Заметим, что в столбце ***++Source++*** указываются строчки кода, а в ***++Basic++*** хранится информация о том, в какие базовые конструкции “трансформировалась” каждая строчка. Из этого можно сделать вывод, что если команда в ***++Source++*** и в ***++Basic++*** совпадают, то она является базовой конструкцией, иначе она является псевдокодом.


 ![li и la являются псевдокодами.](/images/8.png "aspect=1")

Исходя из этого, li и la должны являться псевдокодами. Проверим это с помощью справочника, находящегося внутри эмулятора.


 ![li и la указаны в качестве псевдокодов в RARS 1.6 Help.](/images/9.png "aspect=1")

И как мы можем заметить, мы не ошиблись.

## Описание типов форматов команд для hello01.s

| Команда | Описание команды | Тип формата команды |
|----|----|----|
| li (Load Immediate) | псевдокоманда, которая в нашем коде ассемблируется в addi (Addition Immediate) | I-type |
| la (Load Address) | псевдокоманда, которая в нашем коде ассемблируется в addi (Addition Immediate) и в auipc (Add upper immediate to pc) | I-type |

### Директивы


1. ***++.text++*** - указывает, что последующие пункты (инструкции) будут сохранены в Text Segment.
2. ***++.data++*** - указывает, что последующие пункты будут сохранены в Data Segment.
3. ***++.asciz++*** - указывает, что строка будет сохранена в Data Segment с нулевым ограничителем.

### Системные вызовы в hello01.s

| № вызова | Значение |
|----|----|
| 4 | Вывести строчку с нулевым ограничителем на консоль, адрес на которую хранится в a0 |
| 10 | Завершить программу с кодом 0 |

## Программа hello02.s


 ![](/images/10.png "aspect=1")


Скомпилируем и получим следующие результаты компиляции во вкладке Execute:


 ![](/images/11.png "aspect=1")


Далее запустим нашу программу и посмотрим на результат:


 ![Программа не завершилась с кодом 0...](/images/12.png "aspect=1")

Интересно, мы можем заметить, что программа не завершилась с кодом 0. На самом деле, проблема заключается в том, что здесь в нашем коде не сохранен в a7 системный вызов №10, который как раз отвечает за успешное завершение программы.

### Системные вызовы в hello02.s

| № вызова | Значение |
|----|----|
| 4 | Вывести строчку с нулевым ограничителем на консоль, адрес на которую хранится в a0 |

## Программа hello03.s


 ![](/images/13.png "aspect=1")


Скомпилируем и получим следующие результаты компиляции во вкладке Execute:


 ![](/images/14.png "aspect=1")


Далее запустим нашу программу и посмотрим на результат:


 ![Программа вывела сообщение и успешно завершилась.](/images/15.png "aspect=1")

Как мы видим, программа вывела сообщение “Hello! It works!!!“ и успешно завершилась. Из особенностей можно отметить, что инструкции для Text Segment разбиты на две части, но несмотря на это, они все равно выполняются последовательно.


### Системные вызовы в hello03.s

| № вызова | Значение |
|----|----|
| 4 | Вывести строчку с нулевым ограничителем на консоль, адрес на которую хранится в a0 |
| 10 | Завершить программу с кодом 0 |


## Программа hello-ru.s


 ![](/images/16.png "aspect=1")


Скомпилируем и получим следующие результаты компиляции во вкладке Execute:


 ![](/images/17.png "aspect=1")


Далее запустим нашу программу и посмотрим на результат:


 ![Программа вывела сообщение и успешно завершилась](/images/18.png "aspect=1")

Как мы видим, программа вывела сообщение “Привет. Русский язык выглядит так!!!” и успешно завершилась. Из особенностей можно отметить, что строка может состоять из разного набора букв.


### Системные вызовы в hello-ru.s

| № вызова | Значение |
|----|----|
| 4 | Вывести строчку с нулевым ограничителем на консоль, адрес на которую хранится в a0 |
| 10 | Завершить программу с кодом 0 |


## Программа add-int02.s


 ![](/images/19.png "aspect=1")


 ![](/images/20.png "aspect=1")


Скомпилируем и получим следующие результаты компиляции во вкладке Execute:


 ![](/images/21.png "aspect=1")


Полный Text Segment

***Начало***

 ![](/images/24.png "aspect=1")


***Конец***

 ![](/images/25.png "aspect=1")


Далее запустим нашу программу и в консоли введём два числа 5 и 6.


 ![Программа посчитала сумму чисел и успешно завершилась](/images/22.png "aspect=1")

Как мы можем заметить программа приняла числа, вернула их сумму и успешно завершила работу. Из особенностей можно заметить, что в данном коде реализованы текстовые указания на то, что нужно сделать пользователю, а также на то, что программа выводит.


